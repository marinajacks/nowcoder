在这里，我也会将自己在进行笔试的时候遇到的问题进行一些总结，总结出来的题目会介绍
自己在处理问题的一些思路和方法。


题目： 现在有10个人被一个魔鬼逮住了。魔鬼对于直接把人杀掉的方法不感兴趣了。于是，他就想了一个杀人的新花样。
是这样的，一天晚上，魔鬼向这十个人宣布了游戏规则 ，即明早他要把他们10个人排成一排，然后从一堆既有无限多的
白帽子混会着无限多的黑帽子的帽子堆里为每个人随机抽取一顶帽子，给他们10个人都戴上帽子。因为 10个人是排成一
排的，所以排在第10个的人可以看到前面9个人帽子的颜色，排在第9个人可以看到前面8个人的帽子的颜色，...以此类推。
然后，魔鬼会从排在 第10个人开始，问他，你头上的帽子的颜色是白色还是黑色，如果答对了，就放他走；如果答错了，
就被杀掉。然后同样问排在第9位的人，然后问同样问排在第8位的 人，...以此类推。在这其中，10个人所能做的只有当他
被魔鬼问到的时候，答白色或者黑色。不能有超越此范围的任何行动，不然，魔鬼会把他们10个人全都杀死 。 现在，魔鬼
给他们10个人一个晚上的时间去商量一个对策，使得他们中能存活下来的人越多越好。请问，你会有什么样的对策，请计
算出按照你的对策执行时最坏的情况 下，他们中能有多少人能100%够活下来？期望能活下来的人数又是多少？


思路： 让答的人给前面的人足够多的信息


解答：

从只能回答白或黑，也就是只能2中选1，从而联想到二进制和奇偶性。二进制一下子没想出什么好方法，奇偶性有一些提
示，所以从奇偶性入手。第10个人 以他所见到的9个帽子中白帽的数量的奇偶性作答，例如大家约定白代表偶，黑代表奇，
则第10个人的回答是前9个帽子中白帽的数量的奇偶。他自己有50%的机会。 第9个人听到他的回答后，结合他看到的8顶帽
子中白帽的奇偶，可以知道自己的帽子的颜色，如实作答。第8个人知道9顶帽子中白帽的奇偶，加上听到第9顶帽子的颜 
色，就可以知道前8顶帽子中白帽的奇偶(如果第9个人答白，则前8顶中的白帽奇偶性与第第10个人所说的相反；如果第9
个人答黑，则相同)，再结合所看到前7顶 帽子中的白帽数量，也可以推出自己的帽子颜色，也如实作答。依此类推
，前9个人都可以活下来，第10个人有一半机会。

问题：
给一个超过100G大小的log file, log中存着IP地址, 设计算法找到出现次数最多的IP地址？
与上题条件相同，如何找到top K的IP？如何直接用Linux系统命令实现？


Hash分桶法： 
• 将100G文件分成1000份，将每个IP地址映射到相应文件中：file_id = hash(ip) % 1000 
• 在每个文件中分别求出最高频的IP，再合并 Hash分桶法： 
• 使用Hash分桶法把数据分发到不同文件 
• 各个文件分别统计top K 
• 最后Top K汇总 
Linux命令，假设top 10：sort log_file | uniq -c | sort -nr k1,1 | head -10

Python的问题
1.原始的一个有序数组[1,4,5,6,10],经过旋转后,得到的数组为[6,10,1,4,5]。那么，现在想
找到一个数字，例如4，把这个数的位置定下来。如果不存在的话，返回-1,否则返回原来的位置。
找到比较好的方法，并给出时间复杂度。
1)直接遍历整个表，找到其中某个数的位置。但是，这个方法处理的事件复杂度是O(n)。
def finds(A,b):
    for i in range(len(A)):
        if(A[i]==b):
            return i
        
    return -1
2)使用二分法查找。这种方法的事件复杂度是O(logn)。  
def binfinds(A,b):